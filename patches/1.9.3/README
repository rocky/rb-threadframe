Below is a description of the patches.

About the numbering used below. Numbers at a given power of ten are
supposed to be independent; that is they applied independent of the
other patches at that level. So 000 and 100 and 1xx and and 2xx are
independent.  Likewise for 210, 220, 230 or 210, 211, 212. But 225 is
thought to be dependent on 220. Of course, if patches are skipped
applying higher number patches may give messages about "fuzz" being
applied to line numbers and file offsets.


000-testit.patch:

Adds a script that helps me run the debugger-extension unit tests
easier. Probably not needed if I understood the Ruby testing system
better.
-------------------
110-thread-tracing.patch

Adds per-thread tracing by adding methods Thread#tracing? and Thread#tracing=

The basic mechanism of per-tracing thread was already inside. This
just exposes the ability the set or query thread tracing individually
by adding a couple of methods.

-------------------
210-iseq-field-access.patch

Access to more of the iseq fields: argc, arg_rest, arg_block,
offsetlines, offset2line, local_size, local_table_size, iseq_size,
arg_simple

-------------------
215-iseq-field-access.patch

More InstructionSequence methods: 
InstructionSequence#local_iseq - creates a copy of the instruction sequence
InstructionSequence#local_name(i) returns String name for local entry i

Depends on 210. The two could be combined.

-------------------
220-iseq-eval-source-save.patch:

Give name for top instruction sequences (those that don't have a
parent) a more uniqe and descriptive name. In a debugger we show and
make use of these names in specifying locations.

-------------------
230-top-name.patch:

Adds: "source" method to iseq which if this instruction sequence came
from eval, is the string of the source as a String. TODO: figure out how
to have this "source" field filled out more often.
-------------------
240-iseq-SCRIPT_ISEQS__.patch

A debugger or similar introspection tool needs to be able to find all
instruction sequences and access them. This patch facilitates this by
adding the following behavior, analogous to SCRIPT_LINES__ for
capturing source-code lines.

If SCRIPT_ISEQS__ is defined and is a hash, then every time a new
instruction sequence is added, it is accessible from SCRIPT_ISEQS__
using the "filename" as a key.

Similarly, if ISEQS__ is defined and is a hash, then every time a new
instruction sequence is added, it is accessible from ISEQS__ using its
iseq_name as a key.

If ISEQS__ is set, we don't discard the compile options.
Some programs like a debugger may want a way to reliably restart the program.
-------------------
245-method-arity.patch

Adds Method#arity. 

The unit test added here uses ISEQS__ from
240-iseq-SCRIPT_ISEQS__.patch and adds code to that the unit
test. Probably the unit test here could be rewritten to avoid this.

-------------------
300-os-startup.patch

RubyVM::OS_ARGV and RubyVM::OS_STARTUP_DIR captures the initial @ARGV
and current working directory to make this happen. (Inside a Ruby
program, one can change @ARGV and cwd)

