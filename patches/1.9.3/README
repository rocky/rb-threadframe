Below is a description of the patches.

About the numbering used below. Numbers at a given power of ten are
supposed to be somewhat independent. (See below for what "somewhat
independent" means.

"Somewhat" indpendent patch can be applied independent of the other
patches at that level. So 000 and 100 and 1xx and and 2xx are somewhat
independent.  Likewise for 210, 220, 230 or 210, 211, 212. But 225 is
thought to be dependent on 220. Of course, if patches are skipped
applying higher number patches may give messages about "fuzz" being
applied to line numbers and file offsets.

More on "somewhat" independent. There are two kinds of
dependencies. Those where one feature depends on another
feature. These should be captured by the sub-numbering scheme
above. But there is another kind of dependence due to the patch
mechanism which needs context and line numbers to find a patch. Here
it may be the case that two patches are logically independent but one
patch changes some context lines that another patch will use. This is
captured only by the total ordering of the patch numbers. If some
patches are skipped it is possible the patch mechanism will be able to
handle this giving "fuzz" and "offset line" messages. Alas, more
likely though some hunks of the patch may be rejected.

I have not put a lot of effort into ensuring arbitrary intermediate
patches can be skipped. 


000-testit.patch:

Adds a script that helps me run the debugger-extension unit tests
easier. Probably not needed if I understood the Ruby testing system
better.
-------------------
110-thread-tracing.patch

Adds per-thread tracing by adding methods Thread#tracing? and Thread#tracing=

The basic mechanism of per-tracing thread was already inside. This
just exposes the ability the set or query thread tracing individually
by adding a couple of methods.

-------------------
210-iseq-field-access.patch

Access to more of the iseq fields: argc, arg_rest, arg_block,
offsetlines, offset2line, local_size, local_table_size, iseq_size,
arg_simple

-------------------
215-iseq-field-access.patch

More InstructionSequence methods: 
InstructionSequence#local_iseq - creates a copy of the instruction sequence
InstructionSequence#local_name(i) returns String name for local entry i

Depends on 210. The two could be combined.

-------------------
220-iseq-eval-source-save.patch:

Give name for top instruction sequences (those that don't have a
parent) a more uniqe and descriptive name. In a debugger we show and
make use of these names in specifying locations.

-------------------
230-top-name.patch:

Adds: "source" method to iseq which if this instruction sequence came
from eval, is the string of the source as a String. TODO: figure out how
to have this "source" field filled out more often.
-------------------
240-iseq-SCRIPT_ISEQS__.patch

A debugger or similar introspection tool needs to be able to find all
instruction sequences and access them. This patch facilitates this by
adding the following behavior, analogous to SCRIPT_LINES__ for
capturing source-code lines.

If SCRIPT_ISEQS__ is defined and is a hash, then every time a new
instruction sequence is added, it is accessible from SCRIPT_ISEQS__
using the "filename" as a key.

Similarly, if ISEQS__ is defined and is a hash, then every time a new
instruction sequence is added, it is accessible from ISEQS__ using its
iseq_name as a key.

If ISEQS__ is set, we don't discard the compile options.
Some programs like a debugger may want a way to reliably restart the program.
-------------------
245-method-arity.patch

Adds Method#arity. 

The unit test added here uses ISEQS__ from
240-iseq-SCRIPT_ISEQS__.patch and adds code to that the unit
test. Probably the unit test here could be rewritten to avoid this.

-------------------
300-os-startup.patch

RubyVM::OS_ARGV and RubyVM::OS_STARTUP_DIR captures the initial @ARGV
and current working directory to make this happen. (Inside a Ruby
program, one can change @ARGV and cwd)

-------------------
400-disasm-insns.patch

Add more access to VM opcodes and finer control of disassembly.

rb_iseq_disasm_nochildren() disassembles just the given instruction sequence, not any child instruction sequences (such as those of nested procedures).
rb_child_iseqs (Ruby iseq#child_iseqs) returns and array of child instruction sequences of "iseq".

Also adds access to an instruction's length, name, operand types. 

