Below is a description of the patches.

About the numbering used below. Numbers at a given power of ten are
supposed to be somewhat independent. (See below for what "somewhat
independent" means.

"Somewhat" indpendent patch can be applied independent of the other
patches at that level. So 000 and 100 and 1xx and and 2xx are somewhat
independent.  Likewise for 210, 220, 230 or 210, 211, 212. But 225 is
thought to be dependent on 220. Of course, if patches are skipped
applying higher number patches may give messages about "fuzz" being
applied to line numbers and file offsets.

More on "somewhat" independent. There are two kinds of
dependencies. Those where one feature depends on another
feature. These should be captured by the sub-numbering scheme
above. But there is another kind of dependence due to the patch
mechanism which needs context and line numbers to find a patch. Here
it may be the case that two patches are logically independent but one
patch changes some context lines that another patch will use. This is
captured only by the total ordering of the patch numbers. If some
patches are skipped it is possible the patch mechanism will be able to
handle this giving "fuzz" and "offset line" messages. Alas, more
likely though some hunks of the patch may be rejected.

I have not put a lot of effort into ensuring arbitrary intermediate
patches can be skipped. 


000-testit.patch:

Adds a script that helps me run the debugger-extension unit tests
easier. Probably not needed if I understood the Ruby testing system
better.
-------------------
110-thread-tracing.patch

Adds per-thread tracing by adding methods Thread#tracing? and Thread#tracing=

The basic mechanism of per-tracing thread was already inside. This
just exposes the ability the set or query thread tracing individually
by adding a couple of methods.

-------------------
120-frame-tracing.patch

This patch adds adds the ability to set tracing on or off per frame.
Subsequent frames created which are called a frame with tracing set
off keeps tracing off by default.  (Infrequently one may want to
override this default behavior such as when wants to debug a
debugger.)  When frame returns, the trace bit is taken from the value
set from the previous frame's trace bit.

There is already a such a tracing bit that is similar which is set per
thread, but I don't think this is as useful.  When a trace hook is
called, if the hook yields to the debugged program (in the same
thread), I think the desired intent would be that tracing to turn
tracing back on if that is what it was before entering the hook.

This patch is helps make a debugger "step out" (or in gdb "finish"
command) fast.

Finally, sometimes one wants to do some setup before running a trace
hook, or write some code which simulates calling the hook as though it
were triggered by the runtime, even though it isn't. An example of
this is an immediate call to a debugger from the source code to be
debugged. This is in contrast to waiting for the next event to trigger
a call to a debugger. 

In ruby-debug situation one writes "debugger(:immediate => true)" and
this is used as a workaround for getting into the debugger in a method
at a point when there are no subsequent "line" events in that
method. Although in the next debugger this won't be needed, it still
is a nice thing to have. From the programmer's standpoint such an
immediate stop mechanism more straightforward and predictable.

In such a situation, the setup code ("debugger" above) may also call
other methods before entering the hook and so we want an easy way to
make sure those routines don't get traced just as the setup routine
isn't traced.

One might make a case for removing the trace bit in the thread
structure and having the frame bit subsume that. To be conservative
and compatible, I haven't done that.

-------------------
130-brkpt.patch

Add support for breakpoints in the VM. This allows debuggers to run at full
speed.  

External routines added to RubyVM::InstructionSequence (in brkpt.c): 
  brkpt_alloc - allocate breakpoint vector
  brkpt_set   - set a breakpoint at a given VM offset
  brkpt_unset - unset a breakpoint
  brkpt_get   - see if a breakpoint is set a a particlar VM offset
  brkpt_get   - get list of breakpoints set in this instruction sequence
  
Initial timing evidence by Mark Moseley suggests that the
overhead is negligible.

Previous RubyVM::InstructionSequence patches facilitate getting access
to instruction sequences

-------------------
210-iseq-field-access.patch

Access to more of the iseq fields: argc, arg_rest, arg_block,
offsetlines, offset2line, local_size, local_table_size, iseq_size,
arg_simple

-------------------
215-iseq-field-access.patch

More InstructionSequence methods: 
InstructionSequence#local_iseq - creates a copy of the instruction sequence
InstructionSequence#local_name(i) returns String name for local entry i

Depends on 210. The two could be combined.

-------------------
220-iseq-eval-source-save.patch:

Give name for top instruction sequences (those that don't have a
parent) a more uniqe and descriptive name. In a debugger we show and
make use of these names in specifying locations.

-------------------
230-top-name.patch:

Adds: "source" method to iseq which if this instruction sequence came
from eval, is the string of the source as a String. TODO: figure out how
to have this "source" field filled out more often.
-------------------
240-iseq-SCRIPT_ISEQS__.patch

A debugger or similar introspection tool needs to be able to find all
instruction sequences and access them. This patch facilitates this by
adding the following behavior, analogous to SCRIPT_LINES__ for
capturing source-code lines.

If SCRIPT_ISEQS__ is defined and is a hash, then every time a new
instruction sequence is added, it is accessible from SCRIPT_ISEQS__
using the "filename" as a key.

Similarly, if ISEQS__ is defined and is a hash, then every time a new
instruction sequence is added, it is accessible from ISEQS__ using its
iseq_name as a key.

If ISEQS__ is set, we don't discard the compile options.
Some programs like a debugger may want a way to reliably restart the program.
-------------------
245-method-arity.patch

Adds Method#arity. 

The unit test added here uses ISEQS__ from
240-iseq-SCRIPT_ISEQS__.patch and adds code to that the unit
test. Probably the unit test here could be rewritten to avoid this.

-------------------
300-os-startup.patch

RubyVM::OS_ARGV and RubyVM::OS_STARTUP_DIR captures the initial @ARGV
and current working directory to make this happen. (Inside a Ruby
program, one can change @ARGV and cwd)

-------------------
400-disasm-insns.patch

Add more access to VM opcodes and finer control of disassembly.

rb_iseq_disasm_nochildren() disassembles just the given instruction sequence, not any child instruction sequences (such as those of nested procedures).
rb_child_iseqs (Ruby iseq#child_iseqs) returns and array of child instruction sequences of "iseq".

Also adds access to an instruction's length, name, operand types. 

